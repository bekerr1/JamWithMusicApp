//
//  JWFileController.m
//  JWMixAudioScrubber
//
//  Created by JOSEPH KERR on 1/7/16.
//  Copyright Â© 2016 JOSEPH KERR. All rights reserved.
//

#import "JWFileController.h"
#import "JWDBKeys.h"
@import UIKit;  // for UIImage
@import AVFoundation;  // for audio length

//#define JWSampleFileName @"trimmedMP3-45"
//#define JWSampleFileNameAndExtension @"trimmedMP3-45.m4a"

@interface JWFileController () {
    dispatch_queue_t _imageRetrievalQueue;
    dispatch_queue_t _fileInfoRetrievalQueue;
}
@property id lockFiles;
@property (nonatomic,readwrite) NSArray *downloadedJamTrackFiles;
@property (nonatomic,readwrite) NSArray *jamTrackFiles;
@property (nonatomic,readwrite) NSArray *mp3Files;
@property (nonatomic,readwrite) NSArray *recordingFiles;
@property (nonatomic,readwrite) NSArray *sourceFiles;
@property (nonatomic,readwrite) NSArray *trimmedFiles;
@property (nonatomic) NSMutableArray *mp3filesFilesData;
@property (nonatomic) NSMutableArray *recordingsFilesData;
@property (nonatomic) NSMutableArray *clipsFilesData;
@property (nonatomic) NSMutableArray *finalsFilesData;
@property (nonatomic) NSMutableArray *trimmedFilesData;
@property (nonatomic) NSMutableDictionary *dbMetaData;
@end

@implementation JWFileController

+ (JWFileController *)sharedInstance
{
    static dispatch_once_t singleton_queue;
    static JWFileController *sharedController = nil;
    dispatch_once(&singleton_queue, ^{
        sharedController = [[JWFileController alloc] init];
    });
    
    return sharedController;
}

#pragma mark - Lifecycle

-(instancetype)init {
    if (self = [super init]) {
        [self initdb];
        if (_imageRetrievalQueue == nil)
            _imageRetrievalQueue =
            dispatch_queue_create("imageFileProcessingYoutubeMP3",
                                  dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT,QOS_CLASS_UTILITY, 0));
        
        if (_fileInfoRetrievalQueue == nil)
            _fileInfoRetrievalQueue =
            dispatch_queue_create("imageProcessingSourceAudio",
                                  dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_CONCURRENT,QOS_CLASS_UTILITY, 0));
        
        _dbMetaData = [NSMutableDictionary new];
    }
    
    return self;
}


-(void)update {
    
    [self loadAllData];
    
    NSLog(@"%s\
          \n _recordingsFiles         %ld\
          \n _clipsFiles              %ld\
          \n _finalsFiles             %ld\
          \n _trimmedFiles             %ld\
          \n _downloadedJamTrackFiles %ld\
          \n _jamTrackFiles           %ld",__func__,
          [_recordingsFilesData count],
          [_clipsFilesData count],
          [_finalsFilesData count],
          [_trimmedFilesData count],
          [_downloadedJamTrackFiles count],
          [_jamTrackFiles count]
          );
}

-(void)reload {
    [self update];
}

-(void)readFsData {
    [self loadFilesystemDataPrtotected];
}

- (void)loadAllData {
    [self loadFilesystemDataPrtotected];
    [self loadMetaData];
}

- (void)loadFilesystemDataPrtotected {
    @synchronized(self) {
        [self loadFilesystemData];
        [self processMetaDataForFiles];
    }
}

- (void)loadMetaData {
    [self readMetaData];
    [self readUserOrderedList];
}

-(void)saveMeta {
    [self saveMetaData];
}

- (void)saveUserList {
    [self saveUserOrderedList];
}


#pragma mark -

/*
 
 ./
 ~Documents/Source
 ~Documents/JamTracks
 ~Documents/JamTracks/Downloaded
 ~Documents/JamTrackDownloads
 ~Documents/Downloads
 ~Documents/.trash
 
 In Documents the root directory contains files generated by the app
 JamTracks folder contains JamTracks audio files
 The Downloaded folder JamTracks folder contains JamTracks audio files
 
 */

-(NSString*)documentsDirectoryPath {
    NSString *result = nil;
    NSArray *searchPaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    result = [searchPaths objectAtIndex:0];
    return result;
}

-(NSString*)sourceAudioFilesDirectoryPath {
    return [[self documentsDirectoryPath] stringByAppendingPathComponent:@"Source"];
}
-(NSString*)jamTracksDirectoryPath {
    return [[self documentsDirectoryPath] stringByAppendingPathComponent:@"JamTracks"];
}
-(NSString*)jamTracksDownloadedDirectoryPath {
    return [[self jamTracksDirectoryPath] stringByAppendingPathComponent:@"JamTrackDownloads"];
}
-(NSString*)downloadsDirectoryPath {
    return [[self documentsDirectoryPath] stringByAppendingPathComponent:@"Downloads"];
}
-(NSString*)trashDirectoryPath {
    return [[self documentsDirectoryPath] stringByAppendingPathComponent:@".trash"];
}
-(NSString*)inBoxDirectoryPath {
    return [[self documentsDirectoryPath] stringByAppendingPathComponent:@"InBox"];
}

- (void)initdb {
    
    // CREATE DIRECTORY STRUCTURE AND COPY RESOURCES
    NSString *jtDirectory = [[self documentsDirectoryPath] stringByAppendingPathComponent:@"JamTracks"];
    BOOL isDir = NO;
    if ([[NSFileManager defaultManager] fileExistsAtPath:jtDirectory isDirectory:&isDir]){
        // Exists
    } else {
        NSError *error;
        [[NSFileManager defaultManager] createDirectoryAtPath:jtDirectory
                                  withIntermediateDirectories:YES attributes:nil
                                                        error:&error];
    }
    jtDirectory = [jtDirectory stringByAppendingPathComponent:@"Downloaded"];
    if ([[NSFileManager defaultManager] fileExistsAtPath:jtDirectory isDirectory:&isDir]){
        // Exists
    } else {
        NSError *error;
        [[NSFileManager defaultManager] createDirectoryAtPath:jtDirectory
                                  withIntermediateDirectories:YES attributes:nil
                                                        error:&error];
    }
    jtDirectory = [[self documentsDirectoryPath] stringByAppendingPathComponent:@"JamTrackDownloads"];
    if ([[NSFileManager defaultManager] fileExistsAtPath:jtDirectory isDirectory:&isDir]){
        // Exists
    } else {
        NSError *error;
        [[NSFileManager defaultManager] createDirectoryAtPath:jtDirectory
                                  withIntermediateDirectories:YES attributes:nil
                                                        error:&error];
    }
    jtDirectory = [[self documentsDirectoryPath] stringByAppendingPathComponent:@"Downloads"];
    if ([[NSFileManager defaultManager] fileExistsAtPath:jtDirectory isDirectory:&isDir]){
        // Exists
    } else {
        NSError *error;
        [[NSFileManager defaultManager] createDirectoryAtPath:jtDirectory
                                  withIntermediateDirectories:YES attributes:nil
                                                        error:&error];
    }
    jtDirectory = [[self documentsDirectoryPath] stringByAppendingPathComponent:@".trash"];
    if ([[NSFileManager defaultManager] fileExistsAtPath:jtDirectory isDirectory:&isDir]){
        // Exists
    } else {
        NSError *error;
        [[NSFileManager defaultManager] createDirectoryAtPath:jtDirectory
                                  withIntermediateDirectories:YES attributes:nil
                                                        error:&error];
    }
    // SOURCE DIRECTORY
    NSString *sourceDirectory = [self sourceAudioFilesDirectoryPath];
    if ([[NSFileManager defaultManager] fileExistsAtPath:sourceDirectory isDirectory:&isDir]){
        // Exists
    } else {
        NSError *error;
        [[NSFileManager defaultManager] createDirectoryAtPath:sourceDirectory withIntermediateDirectories:YES attributes:nil
                                                        error:&error];
    }
    
    [self copyResources];
}


- (void)copyResources {
    
    NSLog(@"%@",[self documentsDirectoryPath]);
    NSError *error;
    NSURL *fileURL = nil;
    
    fileURL = [[NSBundle mainBundle] URLForResource:@"TheKillersTrimmedMP3-30" withExtension:@".m4a"];
    [[NSFileManager defaultManager] copyItemAtURL:fileURL
                                            toURL:[self fileURLWithFileName:[fileURL lastPathComponent]] error:&error];
    
    fileURL = [[NSBundle mainBundle] URLForResource:@"AminorBackingtrackTrimmedMP3-45" withExtension:@".m4a"];
    [[NSFileManager defaultManager] copyItemAtURL:fileURL
                                            toURL:[self fileURLWithFileName:[fileURL lastPathComponent]]
                                            error:&error];
    
    fileURL = [[NSBundle mainBundle] URLForResource:@"clipRecording_aminor1" withExtension:@".caf"];
    [[NSFileManager defaultManager] copyItemAtURL:fileURL
                                            toURL:[self fileURLWithFileName:[fileURL lastPathComponent]]
                                            error:&error];
    
    fileURL = [[NSBundle mainBundle] URLForResource:@"clipRecording_killers1" withExtension:@".caf"];
    [[NSFileManager defaultManager] copyItemAtURL:fileURL
                                            toURL:[self fileURLWithFileName:[fileURL lastPathComponent]]
                                            error:&error];
    
    fileURL = [[NSBundle mainBundle] URLForResource:@"clipRecording_killers2" withExtension:@".caf"];
    [[NSFileManager defaultManager] copyItemAtURL:fileURL
                                            toURL:[self fileURLWithFileName:[fileURL lastPathComponent]]
                                            error:&error];
}

#pragma mark -




-(NSURL*)validFileURLForFileName:(NSString*)fileName atRelativePath:(NSString*)relativePath {
    
    NSURL *result;
    NSURL *baseURL = [NSURL fileURLWithPath:[self documentsDirectoryPath]];
    NSString *pathString = @"";
//    for (id path in pathComponents) {
//        pathString = [pathString stringByAppendingPathComponent:path];
//    }
    pathString = [relativePath stringByAppendingPathComponent:fileName];
    NSURL *url = [NSURL fileURLWithPath:pathString relativeToURL:baseURL];
//    NSString *baseName = [[[url lastPathComponent] stringByDeletingPathExtension] stringByRemovingPercentEncoding];
    NSString *baseName = [[[url lastPathComponent] stringByDeletingPathExtension] stringByRemovingPercentEncoding];

    BOOL isDir = NO;
    BOOL alreadyExists = [[NSFileManager defaultManager] fileExistsAtPath:[url path] isDirectory:&isDir];
    if (alreadyExists == NO) {
        result = url;
    } else {
        NSUInteger fileNumber = 2;
        while (alreadyExists) {
            NSString *newFileName = [baseName stringByRemovingPercentEncoding];
            newFileName = [[newFileName stringByAppendingFormat:@"-%ld",fileNumber] stringByAppendingPathExtension:[url pathExtension]];
            pathString = [relativePath stringByAppendingPathComponent:newFileName];
            NSLog(@"newFileName %@",pathString);

            url = [NSURL fileURLWithPath:[pathString stringByRemovingPercentEncoding] relativeToURL:baseURL];
            
            alreadyExists = [[NSFileManager defaultManager] fileExistsAtPath:[url path] isDirectory:&isDir];
            if (alreadyExists == NO) {
                result = url;
                break;
            }
            fileNumber++;
            
        }
    }
    
    return result;
    
}


-(NSURL*)processInBoxItem:(NSURL*)fileURL options:(id)options {
    NSURL *result;
    
    BOOL moveDocOnOpen = NO;
    id optionsAnnotation = options[UIApplicationOpenURLOptionsAnnotationKey];
    if (optionsAnnotation) {
        id moveDocument = optionsAnnotation[@"LSMoveDocumentOnOpen"];
        if (moveDocument) {
            moveDocOnOpen = [moveDocument boolValue];
        }
    }
    
    BOOL openInPlace = NO;
    id optionsOpenInPlace = options[UIApplicationOpenURLOptionsOpenInPlaceKey];
    if (optionsOpenInPlace) {
        openInPlace = [optionsOpenInPlace boolValue];
    }

    BOOL isMusicMemos = NO;
    id optionsSourceApp = options[UIApplicationOpenURLOptionsSourceApplicationKey];
    if (optionsSourceApp) {
        NSLog(@"optionsSourceApp %@",optionsSourceApp);
        if ([optionsSourceApp isEqualToString:@"com.apple.musicmemos"]) {
            NSLog(@"MusicMemos %@",[fileURL lastPathComponent]);
            isMusicMemos = YES;
        }
    }

    
    double audioLength = [self audioLengthForFile:fileURL];
    NSString *destinationRelativePath;
    if (audioLength > 60 ) {
        // is  source
        destinationRelativePath = @"Source";
    } else {
        // is a trim
//        destinationRelativePath = @"";
        destinationRelativePath = @"Source";
    }
    
    NSURL *toFileURL = [self validFileURLForFileName:[fileURL lastPathComponent]  atRelativePath:destinationRelativePath];

    NSError *error;
    BOOL status = [[NSFileManager defaultManager] moveItemAtURL:fileURL toURL:toFileURL error:&error];
    if (status) {
        // Success
        result = toFileURL;
        
    } else {
        NSLog(@"ERROR copy file %@",[error description]);
    }
    
    return result;
}

/*
 
 AIRDROP from mac
 -[AppDelegate application:openURL:options:] file:///private/var/mobile/Containers/Data/Application/6BABD702-3B1E-42F3-8C6D-2532196EDC05/Documents/Inbox/trimmedMP3_B01D917D-5253-4D23-AA05-E39C5FB93A72.m4a {
 UIApplicationOpenURLOptionsAnnotationKey =     {
 LSMoveDocumentOnOpen = 1;
 };
 UIApplicationOpenURLOptionsOpenInPlaceKey = 0;
 }
 
 AIRDROP FROM app MusicMemos
 2016-01-29 22:16:31.445 JamWDev[2035:868086] -[AppDelegate application:openURL:options:] file:///private/var/mobile/Containers/Data/Application/6BABD702-3B1E-42F3-8C6D-2532196EDC05/Documents/Inbox/My%20Idea%207.m4a {
 UIApplicationOpenURLOptionsAnnotationKey =     {
 };
 UIApplicationOpenURLOptionsOpenInPlaceKey = 0;
 UIApplicationOpenURLOptionsSourceApplicationKey = "com.apple.musicmemos";
 }
 
*/
//NSString *const UIApplicationOpenURLOptionsSourceApplicationKey;
//NSString *const UIApplicationOpenURLOptionsAnnotationKey;
//NSString *const UIApplicationOpenURLOptionsOpenInPlaceKey;



#pragma mark -

-(double)audioLengthForFileWithName:(NSString*)fileName {
    double result = 0.0;
    NSString *dbKey = [self dbKeyForFileName:fileName];
    if (dbKey)
        result = [_dbMetaData[dbKey][@"faudiolength"] doubleValue];
    return result;
}

-(NSURL *)fileURLWithFileFlatFileURL:(NSURL*)flatURL{
    NSString *fileName = [flatURL lastPathComponent];
    NSArray *pathComponents = [flatURL pathComponents];
    __block NSUInteger indexToDocuments = 0;
    [pathComponents enumerateObjectsWithOptions:NSEnumerationReverse
                                     usingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
                                         if ([obj isEqualToString:@"Documents"]) {
                                             indexToDocuments = idx;
                                             *stop = YES;
                                         }
                                     }];
    
    NSMutableArray *pathFromDocuments = [NSMutableArray new];
    // Iterate one past Documents til count -1 end slash
    for (NSUInteger i = (indexToDocuments + 1); i <  ([pathComponents count] - 1); i++) {
        [pathFromDocuments addObject:pathComponents[i]];
    }
    
    NSURL *result = [self fileURLWithFileName:fileName  inPath:pathFromDocuments];
    return result;
}

-(NSURL *)fileURLWithFileName:(NSString*)name inPath:(NSArray*)pathComponents{
    NSURL *result;
    NSURL *baseURL = [NSURL fileURLWithPath:[self documentsDirectoryPath]];
    NSString *pathString = @"";
    for (id path in pathComponents) {
        pathString = [pathString stringByAppendingPathComponent:path];
    }
    pathString = [pathString stringByAppendingPathComponent:name];
    NSURL *url = [NSURL fileURLWithPath:pathString relativeToURL:baseURL];
    result = url;
    return result;
}

-(NSURL *)fileURLWithRelativePathName:(NSString*)pathName {
    NSURL *result;
    NSURL *baseURL = [NSURL fileURLWithPath:[self documentsDirectoryPath]];
    NSURL *url = [NSURL fileURLWithPath:pathName relativeToURL:baseURL];
    result = url;
    return result;
}

-(NSURL *)fileURLWithFileName:(NSString*)name {
    return [self fileURLWithFileName:name inPath:nil];
}

//-(NSURL *)fileURLWithFileName:(NSString*)name {
//    return [NSURL fileURLWithPath:[[self documentsDirectoryPath] stringByAppendingPathComponent:name]];
//}


#pragma mark -

- (void)loadFilesystemData {
    
    // SYSTEM GENERATED files
    
    _mp3filesFilesData = [NSMutableArray new];
    _recordingsFilesData = [NSMutableArray new];
    _clipsFilesData = [NSMutableArray new];
    _finalsFilesData = [NSMutableArray new];
    _trimmedFilesData = [NSMutableArray new];

    NSFileManager *fm = [NSFileManager defaultManager];
    
    // DOCUMENTS Directory
    NSDirectoryEnumerator *dirEnum = [fm enumeratorAtURL:[NSURL fileURLWithPath:[self documentsDirectoryPath]]
                              includingPropertiesForKeys:@[NSURLCreationDateKey,NSURLContentAccessDateKey]
                                                 options:NSDirectoryEnumerationSkipsSubdirectoryDescendants
                                            errorHandler:^BOOL(NSURL *url,NSError *error){
                                                return YES;
                                            }];
    NSURL *fileURL;
    while ((fileURL = [dirEnum nextObject])) {
        NSError *error;
        NSDictionary *info = [fm attributesOfItemAtPath:[fileURL path] error:&error];
        
        if (info[NSFileType] == NSFileTypeDirectory) {
            // SKIP Directory
        } else {
            NSString *fname = [fileURL lastPathComponent];
            NSDictionary *recordInfo = @{@"furl":fileURL,@"fsize":info[NSFileSize]};
            
            if ([fname hasPrefix:@"mp3file_"]) {
                [_mp3filesFilesData addObject:recordInfo];
            }
            else if ([fname hasPrefix:@"recording_"] || [fname hasPrefix:@"avrec_"]){
                [_recordingsFilesData addObject:recordInfo];
            }
            else if ([fname hasPrefix:@"clip"]) {
                [_clipsFilesData addObject:recordInfo];
            }
            else if ([fname hasPrefix:@"trimmed"]) {
                [_trimmedFilesData addObject:recordInfo];
            }
            else if ([fname hasPrefix:@"final"]) {
                [_finalsFilesData addObject:recordInfo];
            }
            
        }
    }

//    else if ([fname hasPrefix:@"trimmed"] || [fname hasPrefix:@"fiveSeconds"] )
//        [_trimmedFilesData addObject:recordInfo];

    BOOL recentsFirst = YES;
    NSArray *sortedClipsArray = [_clipsFilesData sortedArrayUsingComparator: ^(id obj1, id obj2) {
        NSDate *createDate1;
        NSDate *createDate2;
        NSError *error;
        [(NSURL *)obj1[@"furl"] getResourceValue:&createDate1 forKey:NSURLCreationDateKey error:&error];
        [(NSURL *)obj2[@"furl"] getResourceValue:&createDate2 forKey:NSURLCreationDateKey error:&error];
        
        NSComparisonResult cresult = [createDate1 compare:createDate2];
        // simple date compare cause recents last
        if (recentsFirst) {
            // swap for Recent first
            if (cresult == NSOrderedAscending) {
                cresult = NSOrderedDescending;
            } else if (cresult == NSOrderedDescending) {
                cresult = NSOrderedAscending;
            }
        }
        
        return cresult;
    }];
    
    _clipsFilesData = [sortedClipsArray mutableCopy];
    
    
    recentsFirst = YES;
    sortedClipsArray = [_trimmedFilesData sortedArrayUsingComparator: ^(id obj1, id obj2) {
        NSDate *createDate1;
        NSDate *createDate2;
        NSError *error;
        [(NSURL *)obj1[@"furl"] getResourceValue:&createDate1 forKey:NSURLCreationDateKey error:&error];
        [(NSURL *)obj2[@"furl"] getResourceValue:&createDate2 forKey:NSURLCreationDateKey error:&error];
        
        NSComparisonResult cresult = [createDate1 compare:createDate2];
        // simple date compare cause recents last
        if (recentsFirst) {
            // swap for Recent first
            if (cresult == NSOrderedAscending) {
                cresult = NSOrderedDescending;
            } else if (cresult == NSOrderedDescending) {
                cresult = NSOrderedAscending;
            }
        }
        
        return cresult;
    }];
    
    _trimmedFilesData = [sortedClipsArray mutableCopy];
    
    // THIS ENDS SYSTEM GENERATED POPULATION CODE
    
    
    _sourceFiles = [self readDirectory:[self sourceAudioFilesDirectoryPath]];
    
    _jamTrackFiles = [self readDirectory:[self jamTracksDirectoryPath]];
    
    _downloadedJamTrackFiles = [self readDirectory:[self jamTracksDownloadedDirectoryPath]];
    
}


-(NSArray*)readDirectory:(NSString*)directoryPath {
    
    NSMutableArray *result = [NSMutableArray new];
    NSFileManager *fm = [NSFileManager defaultManager];
    
    NSDirectoryEnumerator *dirEnum = [fm enumeratorAtURL:[NSURL fileURLWithPath:directoryPath]
                              includingPropertiesForKeys:@[NSURLCreationDateKey,NSURLContentAccessDateKey]
                                                 options:NSDirectoryEnumerationSkipsSubdirectoryDescendants
                                            errorHandler:^BOOL(NSURL *url,NSError *error){
                                                return YES;
                                            }];

    NSURL *fileURL;

    while ((fileURL = [dirEnum nextObject])) {
        NSError *error;
        NSDictionary *info = [fm attributesOfItemAtPath:[fileURL path] error:&error];
        NSString *fname = [fileURL lastPathComponent];
        if (info[NSFileType] == NSFileTypeDirectory  || [fname isEqualToString:@".DS_Store"]) {
            // SKIP
        } else {
            NSDictionary *recordInfo = @{@"furl":fileURL,@"fsize":info[NSFileSize]};
            [result addObject:recordInfo];
        }
    }
    
    return [NSArray arrayWithArray:result];
}


-(void)processMetaDataForFile:(NSDictionary*)fileInfo {
    
    NSURL *fileURL = fileInfo[@"furl"];
    NSString *name = [fileURL lastPathComponent];
    
    NSString *basename = [name stringByDeletingPathExtension];
    NSRange range = [basename rangeOfString:@"_" options:NSBackwardsSearch];
    NSString *dbkey;
    NSString *ftypeName; // ie trimmedMP3_
    double audioLength = 0.0;
    
    if (range.location != NSNotFound && range.location < basename.length) {
        dbkey = [basename substringFromIndex:range.location+1];
        ftypeName = [basename substringToIndex:range.location];
        
        audioLength = [self audioLengthForFile:fileURL];
    }
    
    
    NSString *fileFormatStr = [self audioFileFormatStringForFile:fileURL];
    NSString *fileProcessingFormatStr = [self audioFileProcessingFormatStringForFile:fileURL];
    
    if (dbkey) {
        _dbMetaData[dbkey] = @{
                               @"furl":fileURL,
                               @"fsize":fileInfo[@"fsize"],
                               @"faudiolength":@(audioLength),
                               @"fileformatstr":fileFormatStr,
                               @"fileprocessingformatStr":fileProcessingFormatStr
                               };
    }
    
    //    NSLog(@"%@ %@ %.0f secs",dbkey,ftypeName,audioLength);
    
}

-(void)processMetaDataForFiles {
    
    for (id fileInfo in _trimmedFilesData) {
        [self processMetaDataForFile:fileInfo];
    }
    for (id fileInfo in _mp3filesFilesData) {
        [self processMetaDataForFile:fileInfo];
    }
    for (id fileInfo in _clipsFilesData) {
        [self processMetaDataForFile:fileInfo];
    }
    for (id fileInfo in _recordingsFilesData) {
        [self processMetaDataForFile:fileInfo];
    }
    
    //    NSLog(@"%@",[_dbMetaData description]);
}


#pragma mark -

-(NSArray *)trimmedFiles {
    return [NSArray arrayWithArray:_trimmedFilesData];
}


-(NSString*)dbKeyForFileName:(NSString*)fileName {
    NSString *result;
    
    NSString *basename = [fileName stringByDeletingPathExtension];
    NSRange range = [basename rangeOfString:@"_" options:NSBackwardsSearch];
    if (range.location != NSNotFound && range.location < basename.length) {
        result = [basename substringFromIndex:range.location+1];
    }
    return result;
}

-(double)audioLengthForFile:(NSURL*)fileURL {

    double result = 0;
    NSError *error = nil;
    AVAudioFile *audioFile = [[AVAudioFile alloc] initForReading:fileURL error:&error];
    if (audioFile && error == nil) {
        AVAudioFormat *processingFormat = [audioFile processingFormat];
        result = audioFile.length / processingFormat.sampleRate;
    } else {
        NSLog(@"error in audio file %@",[fileURL lastPathComponent]);
    }
    
    return result;
}



-(NSString *)formatStr:(const AudioStreamBasicDescription *)format {

    NSString *result;
    
    {
        unsigned char bytes[4];
        unsigned long n = format->mFormatID;
        bytes[0] = (n >> 24) & 0xFF;
        bytes[1] = (n >> 16) & 0xFF;
        bytes[2] = (n >> 8) & 0xFF;
        bytes[3] = n & 0xFF;
        result = [[NSString alloc] initWithBytes:bytes  length:4 encoding:NSASCIIStringEncoding];
    }

    
    return result;

}

-(NSString*)audioFileFormatStringForFile:(NSURL*)fileURL {
    
    NSString *result=@"";
    NSError *error = nil;
    AVAudioFile *audioFile = [[AVAudioFile alloc] initForReading:fileURL error:&error];
    if (audioFile && error == nil) {
        //AVAudioFormat *processingFormat = [audioFile processingFormat];
        
        AVAudioFormat *fileFormat = [audioFile fileFormat];
        NSString *fileFormatIdStr;
//        AVAudioFormat *processingFormat = [audioFile processingFormat];
//        NSString *processingFormatIdStr;

//        double durationSeconds = audioFile.length / processingFormat.sampleRate;
        fileFormatIdStr = [self formatStr:fileFormat.streamDescription];
        
        
//        {
//            unsigned char bytes[4];
//            unsigned long n = fileFormat.streamDescription->mFormatID;
//            bytes[0] = (n >> 24) & 0xFF;
//            bytes[1] = (n >> 16) & 0xFF;
//            bytes[2] = (n >> 8) & 0xFF;
//            bytes[3] = n & 0xFF;
//            fileFormatIdStr = [[NSString alloc] initWithBytes:bytes  length:4 encoding:NSASCIIStringEncoding];
//        }
//        
//        {
//            unsigned char bytes[4];
//            unsigned long n = processingFormat.streamDescription->mFormatID;
//            bytes[0] = (n >> 24) & 0xFF;
//            bytes[1] = (n >> 16) & 0xFF;
//            bytes[2] = (n >> 8) & 0xFF;
//            bytes[3] = n & 0xFF;
//            processingFormatIdStr = [[NSString alloc] initWithBytes:bytes  length:4 encoding:NSASCIIStringEncoding];
//        }
        
//        NSLog(@"%s FileFormat_______ : %@",__func__,[NSString stringWithFormat:@"%@ %d ch %.0f %ld %@",
//                                                     fileFormatIdStr,
//                                                     (unsigned int)fileFormat.streamDescription->mChannelsPerFrame,
//                                                     fileFormat.streamDescription->mSampleRate,
//                                                     fileFormat.streamDescription->mBitsPerChannel,
//                                                     fileFormat.interleaved ? @"i" : @"ni"
//                                                     ]);
//        NSLog(@"%s ProcessingFormat_ : %@",__func__,[NSString stringWithFormat:@"%@ %ld ch %.0f %ld %@",
//                                                     processingFormatIdStr,
//                                                     processingFormat.streamDescription->mChannelsPerFrame,
//                                                     processingFormat.streamDescription->mSampleRate,
//                                                     processingFormat.streamDescription->mBitsPerChannel,
//                                                     processingFormat.interleaved ? @"i" : @"ni"
//                                                     ]);
        
        result = [NSString stringWithFormat:@"%@ %d ch %.0f %u %@",
                  fileFormatIdStr,
                  (unsigned int)fileFormat.streamDescription->mChannelsPerFrame,
                  fileFormat.streamDescription->mSampleRate,
                  (unsigned int)fileFormat.streamDescription->mBitsPerChannel,
                  fileFormat.interleaved ? @"i" : @"ni"
                  ];
        
        //        format.interleaved ? @"inter" : @"non-interleaved"
        //        format.standard ? @"Fl32 std" : @"std NO  ",
        
    } else {
        NSLog(@"error in audio file %@",[fileURL lastPathComponent]);
    }
    
    return result;
}

-(NSString*)audioFileProcessingFormatStringForFile:(NSURL*)fileURL {
    
    NSString *result=@"";
    NSError *error = nil;
    AVAudioFile *audioFile = [[AVAudioFile alloc] initForReading:fileURL error:&error];
    if (audioFile && error == nil) {
        //AVAudioFormat *processingFormat = [audioFile processingFormat];
        
//        AVAudioFormat *fileFormat = [audioFile fileFormat];
//        NSString *fileFormatIdStr;
        AVAudioFormat *processingFormat = [audioFile processingFormat];
        NSString *processingFormatIdStr;
        
//        double durationSeconds = audioFile.length / processingFormat.sampleRate;
        
        processingFormatIdStr = [self formatStr:processingFormat.streamDescription];

//        {
//            unsigned char bytes[4];
//            unsigned long n = fileFormat.streamDescription->mFormatID;
//            bytes[0] = (n >> 24) & 0xFF;
//            bytes[1] = (n >> 16) & 0xFF;
//            bytes[2] = (n >> 8) & 0xFF;
//            bytes[3] = n & 0xFF;
//            fileFormatIdStr = [[NSString alloc] initWithBytes:bytes  length:4 encoding:NSASCIIStringEncoding];
//        }
//        
//        {
//            unsigned char bytes[4];
//            unsigned long n = processingFormat.streamDescription->mFormatID;
//            bytes[0] = (n >> 24) & 0xFF;
//            bytes[1] = (n >> 16) & 0xFF;
//            bytes[2] = (n >> 8) & 0xFF;
//            bytes[3] = n & 0xFF;
//            processingFormatIdStr = [[NSString alloc] initWithBytes:bytes  length:4 encoding:NSASCIIStringEncoding];
//        }
        
//        NSLog(@"%s FileFormat_______ : %@",__func__,[NSString stringWithFormat:@"%@ %d ch %.0f %ld %@",
//                                                     fileFormatIdStr,
//                                                     (unsigned int)fileFormat.streamDescription->mChannelsPerFrame,
//                                                     fileFormat.streamDescription->mSampleRate,
//                                                     fileFormat.streamDescription->mBitsPerChannel,
//                                                     fileFormat.interleaved ? @"i" : @"ni"
//                                                     ]);
//        NSLog(@"%s ProcessingFormat_ : %@",__func__,[NSString stringWithFormat:@"%@ %ld ch %.0f %ld %@",
//                                                     processingFormatIdStr,
//                                                     processingFormat.streamDescription->mChannelsPerFrame,
//                                                     processingFormat.streamDescription->mSampleRate,
//                                                     processingFormat.streamDescription->mBitsPerChannel,
//                                                     processingFormat.interleaved ? @"i" : @"ni"
//                                                     ]);

        
        result = [NSString stringWithFormat:@"%@ %u ch %.0f %u %@",
                  processingFormatIdStr,
                  (unsigned int)processingFormat.streamDescription->mChannelsPerFrame,
                  processingFormat.streamDescription->mSampleRate,
                  (unsigned int)processingFormat.streamDescription->mBitsPerChannel,
                  processingFormat.interleaved ? @"i" : @"ni"
                  ];

        
//        result = [NSString stringWithFormat:@"%@/%@ %ld ch(%.1f)%ld %@",
//                  fileFormatIdStr,processingFormatIdStr,
//                  processingFormat.streamDescription->mChannelsPerFrame,
//                  processingFormat.streamDescription->mSampleRate/1000.0,
//                  processingFormat.streamDescription->mBitsPerChannel,
//                  processingFormat.interleaved ? @"i" : @"ni"
//                  ];
        
        //        format.interleaved ? @"inter" : @"non-interleaved"
        //        format.standard ? @"Fl32 std" : @"std NO  ",
        
    } else {
        NSLog(@"error in audio file %@",[fileURL lastPathComponent]);
    }
    
    return result;
}




-(NSArray*)trimmmedFilesForCacheItem:(NSString*)key {
    
    NSMutableArray *fileItems = [NSMutableArray new];
    
    id mp3DataRecord = _mp3FilesInfo[key];
    if (mp3DataRecord) {
        id trimmedFilesValue = mp3DataRecord[@"trimmedfilekeys"];
        if (trimmedFilesValue){
            
            for (id trimKey in trimmedFilesValue) {
                NSString *fname = [NSString stringWithFormat:@"trimmedMP3_%@.m4a",trimKey ? trimKey : @""];
                NSURL *fileURL = [self fileURLWithFileName:fname];
                [fileItems addObject:fileURL];
            }
        }
    }
    
    return [NSArray arrayWithArray:fileItems];
}

-(void)imageForCacheItem:(NSString*)key onCompletion:(JWFileImageCompletionHandler)completion {
    
    id mp3DataRecord = _mp3FilesInfo[key];
    if (mp3DataRecord) {
        NSString *imageURLStr = mp3DataRecord[JWDbKeyYoutubeThumbnailMedium];
        if (imageURLStr) {
            NSURL *imageURL = [NSURL URLWithString:imageURLStr];
            dispatch_async(_imageRetrievalQueue, ^{
                UIImage* youtubeImage = [UIImage imageWithData:[NSData dataWithContentsOfURL:imageURL]];
                dispatch_async(dispatch_get_main_queue(), ^{
                    if (completion)
                        completion(youtubeImage);
                });
            });
            
        } else if (completion) {
            completion(nil);
        }
        
    } else if (completion) {
        completion(nil);
    }
}

-(void)bestImageForCacheItem:(NSString*)key onCompletion:(JWFileImageCompletionHandler)completion {
    
    id mp3DataRecord = _mp3FilesInfo[key];
    if (mp3DataRecord) {
        NSURL *imageURL = [self bestImageURLForMP3Record:mp3DataRecord];
        if (imageURL) {
            dispatch_async(_imageRetrievalQueue, ^{
                UIImage* youtubeImage = [UIImage imageWithData:[NSData dataWithContentsOfURL:imageURL]];
                dispatch_async(dispatch_get_main_queue(), ^{
                    if (completion) {
                        completion(youtubeImage);
                    }
                });
            });
        } else if (completion) {
            completion(nil);
        }
        
    } else if (completion) {
        completion(nil);
    }
}

-(NSURL*)imageURLForCacheItem:(NSString*)key {
    NSURL *result = nil;
    id mp3DataRecord = _mp3FilesInfo[key];
    if (mp3DataRecord) {
        
        NSString *imageURLStr = mp3DataRecord[JWDbKeyYoutubeThumbnailMedium];
        if (imageURLStr)
            result  = [NSURL URLWithString:imageURLStr];
    }
    
    return result;
}

-(NSURL*)bestImageURLForMP3Record:(NSDictionary*)mp3DataRecord {
    if (mp3DataRecord == nil) {
        return nil;
    }
    id urlStr;
    //    urlStr = mp3DataRecord[JWDbKeyYoutubeThumbnailMaxres];
    //    if (!urlStr)
    urlStr = mp3DataRecord[JWDbKeyYoutubeThumbnailHigh];
    if (!urlStr)
        urlStr = mp3DataRecord[JWDbKeyYoutubeThumbnailMedium];
    if (!urlStr)
        urlStr = mp3DataRecord[JWDbKeyYoutubeThumbnailDefault];
    
    NSURL *imageURL = urlStr ? [NSURL URLWithString:urlStr] : nil;
    
    NSLog(@"%s %@",__func__,[imageURL absoluteString]);
    
    return imageURL;
}

-(NSString*)videoTitleForCacheItem:(NSString*)key {
    NSString *result = nil;
    id mp3DataRecord = _mp3FilesInfo[key];
    if (mp3DataRecord) {
        
        id ytData = mp3DataRecord[JWDbKeyYouTubeData];
        if (ytData)
            result = ytData[JWDbKeyYouTubeTitle];
    }
    
    return result;
}

-(NSURL *)fileURLForCacheItem:(NSString*)dbkey
{
    return [self fileURLWithFileName:[NSString stringWithFormat:@"mp3file_%@.mp3",dbkey?dbkey:@""]];
}

//NSString *thisfName = @"mp3file";
//NSString *thisName = [NSString stringWithFormat:@"%@_%@.mp3",thisfName,dbkey?dbkey:@""];
//NSMutableString *fname = [[self documentsDirectoryPath] mutableCopy];
//[fname appendFormat:@"/%@",thisName];
//result = [NSURL fileURLWithPath:fname];


-(NSNumber*)fileSizeForCacheItem:(NSString*)dbKey {

        NSNumber *result;
//        @synchronized(_mp3filesFilesData){
//            result = _mp3filesFilesData[dbKey][@"fsize"];
//        }

//NSString *fileSizeStr; // = [self fileSizeStr:fileSzNumber];
//if (fileSizeStr == nil)
//fileSizeStr = @"";

    return result;
}

-(NSString*)fileSizeStrForCacheItem:(NSString*)dbKey {
    
    NSString *result;
    //        @synchronized(_mp3filesFilesData){
    //            fileSzNumber = _mp3filesFilesData[dbKey][@"fsize"];
    //        }
    
    NSString *fileSizeStr; // = [self fileSizeStr:fileSzNumber];
    if (fileSizeStr == nil)
        fileSizeStr = @"";
    
    return result;
}

-(NSString *)fileSizeStr:(NSNumber*) fileSzNumber{
    NSString *result = nil;
    
    NSUInteger byteSize = [fileSzNumber unsignedLongLongValue];
    if (byteSize > (1024 * 1024))
        result = [NSString stringWithFormat:@"%.2f mb",byteSize/(1024.0f * 1024.0f)];
    else if (byteSize > 1024)
        result = [NSString stringWithFormat:@"%.2f kb",byteSize/1024.0f];
    else
        result = [NSString stringWithFormat:@"%ld bytes",byteSize];
    
    return result;
}


#pragma mark - save retrieve metadata

-(void)saveMetaData {
    [_linksDirector writeToURL:
     [NSURL fileURLWithPath:[[self documentsDirectoryPath] stringByAppendingPathComponent:(NSString*)JWDbKeyLinksDirectoryFileName]] atomically:YES];
    
    [_mp3FilesInfo writeToURL:[NSURL fileURLWithPath:[[self documentsDirectoryPath] stringByAppendingPathComponent:(NSString*)JWDbKeyMP3InfoFileName]] atomically:YES];
    
    NSLog(@"%s LINKSCOUNT [%ld]  MP3INFOCOUNT [%ld]",__func__,[_linksDirector count],[_mp3FilesInfo count]);
    //    NSLog(@"\n%s\nLINKS\n%@\nMP3INFO\n%@",__func__,[_linksDirector description],[_mp3FilesInfo description]);
}
-(void)readMetaData {
    _linksDirector = [[NSMutableDictionary alloc] initWithContentsOfURL:
                      [NSURL fileURLWithPath:[[self documentsDirectoryPath] stringByAppendingPathComponent:(NSString*)JWDbKeyLinksDirectoryFileName]]];
    
    NSMutableDictionary *mp3Dict = [[NSMutableDictionary alloc] initWithContentsOfURL:
                                    [NSURL fileURLWithPath:[[self documentsDirectoryPath] stringByAppendingPathComponent:(NSString*)JWDbKeyMP3InfoFileName]]];
    _mp3FilesInfo = [@{} mutableCopy];
    for (id key in [mp3Dict allKeys]) {
        _mp3FilesInfo[key] = [mp3Dict[key] mutableCopy];
    }
    
    //    _mp3FilesInfo = [[NSMutableDictionary alloc] initWithContentsOfURL:
    //                     [NSURL fileURLWithPath:[[self documentsDirectoryPath] stringByAppendingPathComponent:(NSString*)JWDbKeyMP3InfoFileName]]];
    
    NSLog(@"%s LINKSCOUNT [%ld]  MP3INFOCOUNT [%ld]",__func__,[_linksDirector count],[_mp3FilesInfo count]);
}

-(void)saveDescriptions {
    [_mp3FilesDescriptions writeToURL:[NSURL fileURLWithPath:[[self documentsDirectoryPath] stringByAppendingPathComponent:@"mp3descriptions.dat"]] atomically:YES];
    NSLog(@"%s MP3DESCRIPCOUNT[%ld]",__func__,[_mp3FilesDescriptions count]);
}
-(void)readDescriptions {
    _mp3FilesDescriptions = [[NSMutableDictionary alloc] initWithContentsOfURL:
                             [NSURL fileURLWithPath:[[self documentsDirectoryPath] stringByAppendingPathComponent:@"mp3descriptions.dat"]]];
    NSLog(@"%s MP3DESCRIPCOUNT[%ld]",__func__,[_mp3FilesDescriptions count]);
}

-(void)saveUserOrderedList {
    [_userOrderList writeToURL:
     [NSURL fileURLWithPath:[[self documentsDirectoryPath] stringByAppendingPathComponent:(NSString*)JWDbKeyUserOrderedListFileName]]
                    atomically:YES];
    
    NSLog(@"%s USERLISTCOUNT [%ld]",__func__,[_userOrderList count]);
}
-(void)readUserOrderedList {
    _userOrderList = [[NSMutableArray alloc] initWithContentsOfURL:
                      [NSURL fileURLWithPath:[[self documentsDirectoryPath] stringByAppendingPathComponent:(NSString*)JWDbKeyUserOrderedListFileName]]];
    NSLog(@"%s USERLISTCOUNT [%ld]",__func__,[_userOrderList count]);
}

@end




//
//-(void)convertDescription:(NSString*)dbkey {
//    // Remove the description from ytdata before adding to _mp3Info
//    NSMutableDictionary *ytdata = [_mp3FilesInfo[dbkey][JWDbKeyYouTubeData] mutableCopy];
//    if (ytdata) {
//        //        NSLog(@"%s\nytdata record before\n%@",__func__,[ytdata description]);
//        id ytdescription = ytdata[JWDbKeyYoutubeDataDescription];
//        id ytlocalized = ytdata[JWDbKeyYoutubeDataLocalized];
//        if (ytdescription || ytlocalized) {
//            NSMutableDictionary *mp3DescriptionRecord = [@{} mutableCopy];
//            if (ytdescription) {
//                mp3DescriptionRecord[JWDbKeyYoutubeDataDescription] = ytdescription;
//            }
//            if (ytlocalized) {
//                mp3DescriptionRecord[JWDbKeyYoutubeDataLocalized] = ytlocalized;
//            }
//            mp3DescriptionRecord[JWDbKeyYouTubeDataVideoId] = ytdata[JWDbKeyYouTubeDataVideoId];
//            //            NSLog(@"%s\ndescription record\n%@",__func__,[mp3DescriptionRecord description]);
//            NSString*descriptionKey = [[NSUUID UUID] UUIDString];
//            _mp3FilesDescriptions[descriptionKey] = mp3DescriptionRecord;
//            [ytdata removeObjectForKey:JWDbKeyYoutubeDataDescription];
//            [ytdata removeObjectForKey:JWDbKeyYoutubeDataLocalized];
//            // add the crossreference
//            ytdata[@"ytdescriptionskey"] = descriptionKey;
//            NSLog(@"%s\nytdata record after\n%@",__func__,[ytdata description]);
//            //            NSLog(@"%s\ndescription accessed\n%@",__func__,[ytdata[descriptionKey] description]);
//            _mp3FilesInfo[dbkey][JWDbKeyYouTubeData]=ytdata;
//            //            NSLog(@"%s\ndescription accessed\n%@",__func__,[_mp3FilesDescriptions[descriptionKey] description]);
//        } else {
//            NSLog(@"%s NO DESCRIPTION DATA - RECORD GOOD",__func__);
//        }
//    } else {
//        NSLog(@"%s NO YT DATA ",__func__);

//    BOOL recentsFirst = YES;
//    NSArray *sortedArray = [_mp3filesFilesData sortedArrayUsingComparator: ^(id obj1, id obj2) {
//        NSDate *createDate1;
//        NSDate *createDate2;
//        NSError *error;
//        [(NSURL *)obj1[@"furl"] getResourceValue:&createDate1 forKey:NSURLCreationDateKey error:&error];
//        [(NSURL *)obj2[@"furl"] getResourceValue:&createDate2 forKey:NSURLCreationDateKey error:&error];
//
//        NSComparisonResult cresult = [createDate1 compare:createDate2];
//        // simple date compare cause recents last
//        if (recentsFirst) {
//            // swap for Recent first
//            if (cresult == NSOrderedAscending) {
//                cresult = NSOrderedDescending;
//            } else if (cresult == NSOrderedDescending) {
//                cresult = NSOrderedAscending;
//            }
//        return cresult;
//    }];
//    _mp3filesFilesData = [sortedArray mutableCopy];

